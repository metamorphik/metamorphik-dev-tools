/* eslint-disable no-console */
const { spawnSync } = require("child_process");
const fs = require("fs");
const path = require("path");

const ROOT = path.resolve(__dirname, "..");
const README_PATH = path.join(ROOT, "README.md");

// 1. Run the compare test and capture console output
console.log("Running compare-10k-effects.test.tsx to capture perf numbers...");

// Use a single shell command so Windows (cmd) / Linux (bash) can resolve npx correctly.
const vitestCmd =
  "npx vitest run tests/perf/compare-10k-effects.test.tsx";

const vitest = spawnSync(vitestCmd, {
  cwd: ROOT,
  encoding: "utf8",
  shell: true, // <— important
});

if (vitest.error) {
  console.error("Error running vitest:", vitest.error);
  process.exit(1);
}

if (vitest.status !== 0) {
  console.error("Vitest exited with non-zero code:", vitest.status);
  console.error(vitest.stdout);
  console.error(vitest.stderr);
  process.exit(vitest.status ?? 1);
}

const output = vitest.stdout + "\n" + vitest.stderr;

const lines = output.split(/\r?\n/);
const blockStartIndex = lines.findIndex((line) =>
  line.includes("==== 10k effects comparison over"),
);

if (blockStartIndex === -1) {
  console.error("Could not find comparison block in Vitest output.");
  process.exit(1);
}

const blockLines = [];
for (let i = blockStartIndex; i < lines.length; i++) {
  const line = lines[i];
  blockLines.push(line);
  if (line.includes("====") && i > blockStartIndex) break;
}

const perfBlock = blockLines.join("\n");

// 2. Synthesize a short human-readable summary
// Example line:
// plain useEffect:      avg=2.406ms  min=1.634ms  max=10.180ms
// named useNamedEffect: avg=7.572ms  min=4.833ms  max=21.273ms
// overhead:            avg=5.166ms  (214.76% on average)
let summary = "";
try {
  const plainLine = blockLines.find((l) => l.trim().startsWith("plain useEffect:"));
  const namedLine = blockLines.find((l) =>
    l.trim().startsWith("named useNamedEffect:"),
  );
  const overheadLine = blockLines.find((l) =>
    l.trim().startsWith("overhead:"),
  );

  const plainAvgMatch = plainLine && plainLine.match(/avg=([\d.]+)ms/);
  const namedAvgMatch = namedLine && namedLine.match(/avg=([\d.]+)ms/);
  const overheadAvgMatch = overheadLine && overheadLine.match(/avg=([\d.]+)ms/);
  const overheadPctMatch = overheadLine && overheadLine.match(/\(([\d.]+)%/);

  if (plainAvgMatch && namedAvgMatch && overheadAvgMatch && overheadPctMatch) {
    const plainAvg = parseFloat(plainAvgMatch[1]);
    const namedAvg = parseFloat(namedAvgMatch[1]);
    const overheadAvg = parseFloat(overheadAvgMatch[1]);
    const overheadPct = parseFloat(overheadPctMatch[1]);
    const perEffectUs = (overheadAvg / 10000) * 1000; // ms -> µs

    summary =
      `- 10k plain **useEffect**: \`${plainAvg.toFixed(3)}ms\`\n` +
      `- 10k **useNamedEffect**: \`${namedAvg.toFixed(3)}ms\`\n` +
      `- Overhead: \`${overheadAvg.toFixed(3)}ms\` per 10k effects (~\`${perEffectUs.toFixed(
        3,
      )}µs\` per effect, ~\`${overheadPct.toFixed(2)}%\` in this synthetic test)`;
  }
} catch (e) {
  console.error("Failed to parse perf block:", e);
}

if (!summary) {
  console.error("Could not parse perf numbers for summary.");
  process.exit(1);
}

// 3. Inject or replace a PERF section in README
const readme = fs.readFileSync(README_PATH, "utf8");

const markerStart = "<!-- PERF-SECTION:START -->";
const markerEnd = "<!-- PERF-SECTION:END -->";

const newSection =
  `${markerStart}\n` +
  `## ⚡ Performance (generated by CI)\n\n` +
  `These numbers come from a synthetic microbenchmark using React Test Renderer + happy-dom.\n` +
  `They measure wrapper overhead for 10,000 empty effects (no real work in the body):\n\n` +
  `${summary}\n\n` +
  `The raw numbers exaggerate the difference because \`useEffect\` does almost no work in this environment.\n` +
  `In real components, effect bodies perform useful work (subscriptions, DOM I/O, analytics), and the fixed ~${perEffectUs.toFixed(1)}µs per-effect overhead of \`useNamedEffect\` is diluted into that cost.\n` +
  `${markerEnd}`;

let nextReadme;
if (readme.includes(markerStart) && readme.includes(markerEnd)) {
  const before = readme.split(markerStart)[0];
  const after = readme.split(markerEnd)[1];
  nextReadme = before + newSection + after;
} else {
  nextReadme = readme + "\n\n" + newSection + "\n";
}

fs.writeFileSync(README_PATH, nextReadme, "utf8");

console.log("README.md perf section updated.");
